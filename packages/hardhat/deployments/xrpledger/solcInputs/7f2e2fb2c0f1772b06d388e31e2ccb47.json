{
  "language": "Solidity",
  "sources": {
    "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// solhint-disable-next-line interface-starts-with-i\ninterface AggregatorV3Interface {\n  function decimals() external view returns (uint8);\n\n  function description() external view returns (string memory);\n\n  function version() external view returns (uint256);\n\n  function getRoundData(\n    uint80 _roundId\n  ) external view returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n\n  function latestRoundData()\n    external\n    view\n    returns (uint80 roundId, int256 answer, uint256 startedAt, uint256 updatedAt, uint80 answeredInRound);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/ILiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ILiquidityManager {\n    function getTotalLiquidityForToken(address token) external view returns (uint128 totalLiquidity);\n}"
    },
    "contracts/IndexAggregator.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport {AggregatorV3Interface} from \"@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol\";\nimport {IERC20} from \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport {ILiquidityManager} from \"./ILiquidityManager.sol\";\n\nuint32 constant CALLBACK_GAS_LIMIT = 4_000_000;\n\nstruct ChainLinkData {\n    address router;\n    address link;\n    uint64 currentChainSelectorId;\n    bytes32 keyHash;\n}\n\nstruct TokenInfo {\n    string _symbol;\n    address _address;\n    uint32 _chainId;\n    address _aggregator;\n    string[] _tags;\n}\n\nstruct LiquidityMessage {\n    address token;\n    uint256 liquidity;\n    uint32 chainId;\n    uint256 timestamp;\n} \n\nstruct SupplyMessage {\n    address token;\n    uint256 supply;\n    uint32 chainId;\n    uint256 timestamp;\n}\n\nstruct AggregatorParams {\n    uint256 _timeWindow; \n    uint256 _sampleSize;\n    // uint32 _chainId;\n    uint256 _bribeUnit;\n}\n\nstruct IndexUpdateMessage {\n    LiquidityMessage[] liquidityMessages;\n    SupplyMessage[] supplyMessages;\n}\n\nenum PayFeesIn {\n    Native,\n    LINK\n}\n\nerror NotEnoughBalance(uint256 currentBalance, uint256 calculatedFees);\n\n\ncontract IndexAggregator {\n    TokenInfo[] public tokenInfo;\n    TokenInfo[] tmpTokens;\n    ILiquidityManager public liquidityManager;\n    mapping(string => uint256) public tokens;\n    string[] public tokenSymbols;\n\n    \n    SupplyMessage[] public supplyMessages;\n    LiquidityMessage[] public liquidityMessages;\n    // TaggingVerifier public taggingVerifier;\n\n    uint256[] public totalSupplies;\n    uint256[] public liquidities;\n    uint256[] public tokenParamsTimestampUpdates;\n\n    mapping(uint256 => uint256[]) public movingAverage;\n    uint256 sampleSize;\n    uint256 timeWindow;\n    uint256 samplingFrequency;\n    uint256 lastSampleTime;\n    uint256[] public lastIndexOrder;\n    mapping(string => uint256[]) public tagsIndexOrder; \n    mapping(string => uint256) public tagsIndexTimestamp;\n    uint256 public lastIndexTimestamp;\n    uint256 public bribeUnit;\n    uint32 public chainId;\n    uint32 public mainChainId;\n\n    ChainLinkData public chainLinkData;\n\n    mapping(uint64 => address) public chainSelectorIdToSidechainAddress;\n\n\n    constructor(TokenInfo[] memory _tokenInfo,  address _liquidityManager, address  router, AggregatorParams memory _aggregatorParams\n    ) {\n        sampleSize = _aggregatorParams._sampleSize;\n        timeWindow = _aggregatorParams._timeWindow;\n        samplingFrequency = timeWindow / sampleSize;\n        bribeUnit = _aggregatorParams._bribeUnit;\n        liquidityManager = ILiquidityManager(_liquidityManager);\n        for (uint256 i = 0; i < _tokenInfo.length; i++) {\n            tokenInfo.push(_tokenInfo[i]);\n            tokenSymbols.push(_tokenInfo[i]._symbol);\n            tokens[_tokenInfo[i]._symbol] = i;\n            totalSupplies.push(IERC20(_tokenInfo[i]._address).totalSupply());\n        }\n    }\n\n    // Initialize methods\n\n    // function setTaggingVerifier(address _taggingVerifier) external {\n    //     taggingVerifier = TaggingVerifier(_taggingVerifier);\n    // }\n\n    function setChainId(uint32 _chainId, uint32 _mainChainId) external {\n        chainId = _chainId;\n        mainChainId = _mainChainId;\n    }\n\n    function isMainChain() public view returns (bool) {\n        return chainId == mainChainId;\n    }\n\n    function setSideChainAddress(\n        uint64 chainSelectorId,\n        address sideChainAddress\n    ) external {\n        chainSelectorIdToSidechainAddress[chainSelectorId] = sideChainAddress;\n    }\n\n    function updateTokenParams(uint256[] memory _totalSupplies, uint256[] memory _liquidities) external {\n\n        for (uint256 i = 0; i < tokenInfo.length; i++) {\n            if (tokenInfo[i]._chainId == chainId) {\n                liquidities[i] = liquidityManager.getTotalLiquidityForToken(tokenInfo[i]._address);\n                totalSupplies[i] = IERC20(tokenInfo[i]._address).totalSupply();\n                tokenParamsTimestampUpdates[i] = block.timestamp;\n            }\n        }\n\n        if(isMainChain()){\n            for (uint256 i = 0; i < totalSupplies.length; i++) {\n                for (uint256 j = 0; j < tokenInfo.length; j++) {\n                    if (tokenInfo[j]._address == supplyMessages[i].token) {\n                        totalSupplies[j] = supplyMessages[i].supply;\n                        tokenParamsTimestampUpdates[j] = liquidityMessages[i].timestamp;\n                    }\n                    continue;\n                }\n            }\n\n            for (uint256 i = 0; i < liquidities.length; i++) {\n                for (uint256 j = 0; j < tokenInfo.length; j++) {\n                    if (tokenInfo[j]._address == liquidityMessages[i].token) {\n                        liquidities[j] = liquidityMessages[i].liquidity;\n                        tokenParamsTimestampUpdates[j] = liquidityMessages[i].timestamp;\n                    }\n                    continue;\n                }\n            }\n        }\n\n        if(!isMainChain()){\n            SupplyMessage[] memory _supplyMessages = new SupplyMessage[](tokenInfo.length);\n            LiquidityMessage[] memory _liquidityMessages = new LiquidityMessage[](tokenInfo.length);\n            for (uint256 i = 0; i < tokenInfo.length; i++) {\n                if(chainId == tokenInfo[i]._chainId){\n                    _supplyMessages[i] = SupplyMessage(tokenInfo[i]._address, _totalSupplies[i], chainId, block.timestamp);\n                    _liquidityMessages[i] = LiquidityMessage(tokenInfo[i]._address, _liquidities[i], chainId, block.timestamp);\n                }\n            }\n        }\n    }\n\n\n    function checkTokenParams() public {\n        for (uint256 i = 0; i < tokenInfo.length; i++) {\n            if (block.timestamp - tokenParamsTimestampUpdates[i] >= timeWindow) {\n                liquidities[i] = liquidityManager.getTotalLiquidityForToken(tokenInfo[i]._address);\n                totalSupplies[i] = IERC20(tokenInfo[i]._address).totalSupply();\n                tokenParamsTimestampUpdates[i] = block.timestamp;\n            }\n        }\n    }\n\n\n    function receiveFromAxelar(\n        IndexUpdateMessage memory indexMessage\n    ) external {\n\n        // add @axelar-network/axelar-cgp-solidity logic here\n\n        for (uint256 i = 0; i < indexMessage.liquidityMessages.length; i++) {\n            LiquidityMessage memory liquidityMessage = indexMessage.liquidityMessages[i];\n            liquidityMessages.push(liquidityMessage);\n        }\n        for (uint256 i = 0; i < indexMessage.supplyMessages.length; i++) {\n            SupplyMessage memory supplyMessage = indexMessage.supplyMessages[i];\n            supplyMessages.push(supplyMessage);\n        }\n    }\n\n    function collectPriceFeeds() external {\n        require(block.timestamp - lastSampleTime >= samplingFrequency, \"IndexAggregator: Sampling frequency not reached\");\n\n        if (block.timestamp - lastSampleTime >= timeWindow) {\n            for (uint256 i = 0; i < tokenInfo.length; i++) {\n                if (movingAverage[i].length > 0) {\n                    movingAverage[i].pop();\n                }\n            }\n        }\n\n        for (uint256 i = 0; i < tokenInfo.length; i++) {\n            (, int256 answer, , , ) = AggregatorV3Interface(tokenInfo[i]._aggregator).latestRoundData();\n\n            movingAverage[i].push(uint256(answer));\n            uint256 sum = 0;\n            if (movingAverage[i].length > sampleSize) {\n                movingAverage[i].pop();\n            }\n            for (uint256 j = 0; j < movingAverage[i].length; j++) {\n                sum += movingAverage[i][j];\n            }\n        }\n        lastSampleTime = block.timestamp;\n        // if there is enough bribe pay it to the caller\n        if (bribeUnit > 0) {\n            payable(msg.sender).transfer(bribeUnit);\n        }\n    }\n}"
    },
    "contracts/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}"
    },
    "contracts/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool{\n    function liquidity() external view returns (uint128);\n    function token0() external view returns (address);\n    function token1() external view returns (address);\n}"
    },
    "contracts/LiquidityManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IUniswapV3Factory.sol\";\nimport {ILiquidityManager} from \"./ILiquidityManager.sol\";\nimport \"./IUniswapV3Pool.sol\";\n\ncontract LiquidityManager is ILiquidityManager {\n    IUniswapV3Factory public factory;\n    uint24[] public feeTiers = [500, 3000, 10000]; // Example fee tiers: 0.05%, 0.3%, 1% these are Uniswap V3 standards\n    address[] public comparisonTokens;\n\n    constructor(address _factory, address[] memory _comparisonTokens) {\n        factory = IUniswapV3Factory(_factory);\n        comparisonTokens = _comparisonTokens;\n    }\n\n    function getPoolsForToken(address token) public view returns (address[] memory) {\n        uint256 poolCount = 0;\n        address[] memory tempPools = new address[](comparisonTokens.length * feeTiers.length);\n\n        for (uint256 i = 0; i < comparisonTokens.length; i++) {\n            if (comparisonTokens[i] == token) continue;\n            for (uint256 j = 0; j < feeTiers.length; j++) {\n                address pool = factory.getPool(token, comparisonTokens[i], feeTiers[j]);\n                if (pool != address(0)) {\n                    tempPools[poolCount] = pool;\n                    poolCount++;\n                }\n            }\n        }\n\n        // Create an array of the actual size\n        address[] memory pools = new address[](poolCount);\n        for (uint256 i = 0; i < poolCount; i++) {\n            pools[i] = tempPools[i];\n        }\n\n        return pools;\n    }\n\n    function getTotalLiquidityForToken(address token) public view returns (uint128 totalLiquidity) {\n        address[] memory pools = getPoolsForToken(token);\n        for (uint256 i = 0; i < pools.length; i++) {\n            totalLiquidity += IUniswapV3Pool(pools[i]).liquidity();\n        }\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}